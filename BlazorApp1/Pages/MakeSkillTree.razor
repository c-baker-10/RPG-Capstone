@page "/makeskilltree"

@using Objects
@using Microsoft.JSInterop
@using System;
@using System.IO;
@using System.Text;
@using sf = Syncfusion.Blazor.Diagram
@inject IJSRuntime JS;

<h3>Make a Skill Tree</h3>

<label for="Files">Node options:</label>
<select name="Files" id="Files" @bind="NodeInput">
    <option disabled selected value> -- select an option -- </option>
    <option> Add Node </option>
    <option> Remove Node </option>
    <option> Edit Selected Node </option>
    <option value="Connect Nodes"> @NodeConnections </option>
    <option> Start Node </option>
</select>

<button class="btn btn-primary" @onclick="Nodeinput"> enter </button>

<label for="Files">Connection options:</label>
<select name="Files" id="Files" @bind="ConnectionInput">
    <option disabled selected value> -- select an option -- </option>
    <option> Add Connection </option>
    <option> Remove Connection </option>
</select>

<button class="btn btn-primary" @onclick="Connectioninput"> enter </button>

<button class="btn btn-primary" @onclick="SaveTree" style="float: right" > Save Skill Tree </button>

<br/>

<p style ="display:inline">Selected Node: </p>
@if (SelectedNode != null)
{
     <p style="display:inline"> <b> @SelectedNode.name </b> </p>
}
else
{
    <p style="display:inline"> <b> None </b> </p>
}

<p style="display:inline"> Selected Connector: </p>
@if (SelectedConnector != null)
{
    <p style="display:inline"> <b> @SelectedConnector.name </b> </p>
}
else
{
    <p style="display:inline"> <b> None </b> </p>
}

@if (connecting)
{
    <p style="display:inline"> <b> @SelectedNode.name -> @ConnectedNodeName</b> </p>
}

@if (SelectedNode != null && editing)
{
    <div align="left">
        <p> User Input: </p>
        <EditForm Model="@SelectedNode">
            <label for="Name"> Node Name</label>
            <InputText id="Name" @bind-Value="SelectedNode.name" /> <br/>
            <label for="Edtype"> Node Education Type</label>
            <InputText id="Edtype" @bind-Value="SelectedNode.EducationType" /> <br />
            <label for="Entype"> Node Entry Score</label>
            <InputText id="Entype" @bind-Value="SelectedNode.entryScore" />
        </EditForm>
        <ul>
            @if (SelectedNode.NodeConnections != null)
            {
                <p style="display:inline">Node Connections: </p>
                @if (SelectedNode.NodeConnections.Count == 0)
                {
                    <p style="display:inline"> None </p>
                }
                else
                {
                    @foreach (Node node in SelectedNode.NodeConnections)
                    {
                        <p style="display:inline"> @node.name </p>
                    }
                }
            }
        </ul>
      
        <button class="btn btn-primary" @onclick="DoneEdit"> Done</button>
    </div>
}

@foreach (Connectors Connect in Connections)
{
    <div class="resizedrag" @onclick="() => SelectedConnectorMethod(Connect)" id="@Connect.name"> <p> @Connect.name </p></div>
}

@foreach (Node node in Nodes)
{
    <div class="draggable" @onclick="() => SelectedNodeMethod(node)" id="@node.name"> <p style="color:black"> @node.name </p> </div>
}

<!--
    work in progress
    <SfDiagramComponent @ref="diagram" Height="600px" />
-->

@code {
    sf.SfDiagramComponent diagram;
    List<Node> Nodes = new List<Node>();
    List<Connectors> Connections = new List<Connectors>();

    Node SelectedNode, node;
    Connectors SelectedConnector, connector;

    string NodeInput;
    string ConnectionInput;
    string ConnectedNodeName;
    string NodeConnections = "Connect Nodes";

    int SelectedNodeIndex = -1;

    // allows divs to be dragged and dropped
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("dragAndDrop", ".draggable");
        await JS.InvokeVoidAsync("resizeDrag", ".resizedrag");
    }

    private void Nodeinput()
    {
        if (NodeInput == "Add Node"){ AddNode(); }
        if (NodeInput == "Remove Node") { RemoveNode(); }
        if (NodeInput == "Edit Selected Node") { EditNode(); }
        if (NodeInput == "Connect Nodes") { ConnectNode(); }
        if (NodeInput == "Start Nodes") { SelectStart(); }
    }

    private void Connectioninput()
    {
        if (ConnectionInput == "Add Connection") { AddConnection(); } 
        if (ConnectionInput == "Remove Connection") { RemoveConnector(); }
    }

    // sets clicked node to be selected
    private void SelectedNodeMethod(Node node)
    {
        if (!connecting)
        {
            if (SelectedNode != node)
            {
                SelectedNode = node;
            }
        }
        else
        {
            if (SelectedNode != null && SelectedNode != node && !SelectedNode.NodeConnections.Contains(node))
            {
                ConnectedNodeName = node.name;
                SelectedNode.NodeConnections.Add(node);
            }
        }
    }

    // sets clicked connector to be selected
    private void SelectedConnectorMethod(Connectors connector)
    {
        if (SelectedConnector != connector)
        {
            SelectedConnector = connector;
        }
    }

    private int index = 1;
    // adds a node to the page
    private void AddNode()
    {
        Node node = new Node("N" + index);
        editing = true;
        Nodes.Add(node);
        index++;
    }

    // removes selected node from the page
    private void RemoveNode()
    {
        Nodes.Remove(SelectedNode);
        SelectedNode = null;
    }

    private int ConnectionsIndex = 1;

    // new function to add connections, work in progress
    private void AddConnector()
    {
        diagram.InteractionController = sf.DiagramInteractions.DrawOnce;
        diagram.DrawingObject = new sf.Connector()
            {
                ID = "connector1",
                Type = sf.ConnectorSegmentType.Straight,
            };
    }

    // adds a connector to the page
    private void AddConnection()
    {
        Connections.Add(connector = new Connectors("C" + ConnectionsIndex));
        ConnectionsIndex++;
    }

    // removes selected connector from the page
    private void RemoveConnector()
    {
        Connections.Remove(SelectedConnector);
        SelectedConnector = null;
    }

    private bool editing = false;
    // add/update values to selected node and review its information
    private void EditNode()
    {
        editing = true;

    }
    // get out of editing mode
    private void DoneEdit()
    {
        editing = false;
    }

    private bool connecting = false;
    private void ConnectNode()
    {
        if(connecting == true)
        {
            NodeConnections = "Connecting Nodes";
            connecting = false;
        }
        else
        {
            NodeConnections = "Stop Connecting Nodes";
            ConnectedNodeName = "";
            connecting = true;
        }
    }

    private void SelectStart()
    {
        if (SelectedNode.startingNode == false)
        {
            SelectedNode.startingNode = true;
        }
    }


    int FileIndex = 1;
    string FileName, FileDesPath, TreeInfo;
    private float[] posistion = new float[5];

    private async void SaveTree()
    {
        // set file name and destination path
        FileName = "SkillTree" + FileIndex;
        FileDesPath = Directory.GetCurrentDirectory() + @"\SavedSkillTrees\" + FileName;

        // Check if file already exists. If yes, adds one to the exisiting file name
        while (true)
        {
            if (File.Exists(FileDesPath))
            {
                // update file name and destination path if current file name exists
                FileIndex++;
                FileName = "SkillTree" + FileIndex;
                FileDesPath = Directory.GetCurrentDirectory() + @"\SavedSkillTrees\" + FileName;
            }
            else
            {
                break;
            }
        }

        // Create a FileStream Object to write to a text file. The parameters are complete path of the text file in the
        // system, in Create mode, the access to this process is. Write and for other processes is None
        FileStream FileWrite = new FileStream(FileDesPath, FileMode.Create, FileAccess.Write, FileShare.None);
        FileIndex++;

        // node info section
        TreeInfo = "NODE|\n";

        foreach (Node node in Nodes)
        {
            // store node name
            //TreeInfo += "Node name: " + node.name + "\n";
            TreeInfo += node.name + ";";

            // store node description
            //TreeInfo += "Node description: ";
            if (node.description != null)
            {
                TreeInfo += node.description + ";";
            }
            else
            {
                TreeInfo += "null;";
            }

            // store node links
            //TreeInfo += "Node links: ";
            if (node.links != null)
            {
                TreeInfo += node.links + ";";
            }
            else
            {
                TreeInfo += "null;";
            }


            // get x and y posistions and width and height
            posistion = await JS.InvokeAsync<float[]>("xyPosistion", node.name);

            // store x and y posistions and width and height
            //TreeInfo += "X value: "; 
            TreeInfo += posistion[0] + "px;";
            //TreeInfo += "Y value: ";
            TreeInfo += posistion[1] + "px;";
            //TreeInfo += "Width value: ";
            TreeInfo += posistion[2] + "px;";
            //TreeInfo += "Height value: "; 
            TreeInfo += posistion[3] + "px;";

            TreeInfo += node.startingNode +";";

            TreeInfo += node.EducationType +";";

            TreeInfo += node.entryScore + ";";

            TreeInfo += "\n";

        }

        // node connection info section
        TreeInfo += "NODE-CONNECTIONS|\n";
        foreach (Node node in Nodes)
        {
            TreeInfo += node.name + ";";
            foreach(Node ConnectNode in node.NodeConnections)
            {
                TreeInfo += ConnectNode.name + ";";
            }
            TreeInfo += "\n";
        }

        // connector info section
        TreeInfo += "CONNECTORS|\n";

        foreach (Connectors connect in Connections)
        {
            // store general info
            //TreeInfo += "Connector name: ";
            TreeInfo += connect.name + ";";

            // get x and y posistions and width and height
            posistion = await JS.InvokeAsync<float[]>("xyPosistion", connect.name);

            // store x and y posistions and width and height
            //TreeInfo += "X value: ";
            TreeInfo += posistion[0] + "px;";
            //TreeInfo += "Y value: ";
            TreeInfo += posistion[1] + "px;";
            //TreeInfo += "Width value: ";
            TreeInfo += posistion[2] + "px;";
            //TreeInfo += "Height value: ";
            TreeInfo += posistion[3] + "px;";

            TreeInfo += "\n";
        }

        // Store the text in a byte array with. UTF8 encoding (8-bit Unicode. Transformation Format)
        byte[] writeArr = Encoding.UTF8.GetBytes(TreeInfo);

        // Using the Write method write the encoded byte array to the textfile
        FileWrite.Write(writeArr, 0, TreeInfo.Length);

        // Closee the FileStream object
        FileWrite.Close();

    }

}
